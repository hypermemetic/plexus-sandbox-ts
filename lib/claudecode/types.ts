// Auto-generated by hub-codegen
// Do not edit manually

import type { Position } from '../cone/types';

/** A buffered event in the stream */
export interface BufferedEvent {
  /** The chat event */
  event: ChatEvent;
  /** Sequence number within the stream */
  seq: number;
  /** Timestamp when event was received */
  timestamp: number;
}

/** Events emitted during chat streaming */
export type ChatEvent = ChatEvent_Start | ChatEvent_Content | ChatEvent_Thinking | ChatEvent_ToolUse | ChatEvent_ToolResult | ChatEvent_Complete | ChatEvent_Passthrough | ChatEvent_Error;

/** Chat started - user message stored, streaming begins */
export interface ChatEvent_Start {
  type: 'start';
  id: string;
  userPosition: Position;
}

/** Content chunk (streaming tokens) */
export interface ChatEvent_Content {
  type: 'content';
  text: string;
}

/** Thinking block - Claude's internal reasoning */
export interface ChatEvent_Thinking {
  type: 'thinking';
  thinking: string;
}

/** Tool use detected */
export interface ChatEvent_ToolUse {
  type: 'tool_use';
  input: unknown;
  toolName: string;
  toolUseId: string;
}

/** Tool result received */
export interface ChatEvent_ToolResult {
  type: 'tool_result';
  isError: boolean;
  output: string;
  toolUseId: string;
}

/** Chat complete - response stored, head updated */
export interface ChatEvent_Complete {
  type: 'complete';
  claudeSessionId: string;
  newHead: Position;
  usage: ChatUsage | null;
}

/** Passthrough for unrecognized Claude Code events
Data is stored separately (referenced by handle) and also forwarded inline */
export interface ChatEvent_Passthrough {
  type: 'passthrough';
  data: unknown;
  eventType: string;
  handle: string;
}

/** Error during chat */
export interface ChatEvent_Error {
  type: 'error';
  message: string;
}


/** Result of starting an async chat (non-blocking) */
export type ChatStartResult = ChatStartResult_Started | ChatStartResult_Error;

export interface ChatStartResult_Started {
  type: 'started';
  /** Session ID - use this with poll() to get events */
  sessionId: string;
}

export interface ChatStartResult_Error {
  type: 'error';
  message: string;
}


/** Token usage information */
export interface ChatUsage {
  costUsd?: number | null;
  inputTokens?: number | null;
  numTurns?: number | null;
  outputTokens?: number | null;
}

/** ClaudeCode session configuration */
export interface ClaudeCodeConfig {
  /** Claude Code's internal session ID (for --resume) */
  claudeSessionId?: string | null;
  /** Created timestamp */
  createdAt: number;
  /** The canonical head - current position in conversation tree */
  head: Position;
  /** Unique identifier for this session */
  id: string;
  /** Enable loopback mode - routes tool permissions through parent for approval */
  loopbackEnabled: boolean;
  /** MCP server configuration (JSON) */
  mcpConfig?: unknown;
  /** Additional metadata */
  metadata?: unknown;
  /** Model to use */
  model: Model;
  /** Human-readable name */
  name: string;
  /** System prompt / instructions */
  systemPrompt?: string | null;
  /** Last updated timestamp */
  updatedAt: number;
  /** Working directory for Claude Code */
  workingDir: string;
}

/** Lightweight session info (for listing) */
export interface ClaudeCodeInfo {
  claudeSessionId?: string | null;
  createdAt: number;
  head: Position;
  id: string;
  loopbackEnabled: boolean;
  model: Model;
  name: string;
  workingDir: string;
}

/** Result of creating a session */
export type CreateResult = CreateResult_Created | CreateResult_Error;

export interface CreateResult_Created {
  type: 'created';
  head: Position;
  id: string;
}

export interface CreateResult_Error {
  type: 'error';
  message: string;
}


/** Result of deleting a session */
export type DeleteResult = DeleteResult_Deleted | DeleteResult_Error;

export interface DeleteResult_Deleted {
  type: 'deleted';
  id: string;
}

export interface DeleteResult_Error {
  type: 'error';
  message: string;
}


/** Result of forking a session */
export type ForkResult = ForkResult_Forked | ForkResult_Error;

export interface ForkResult_Forked {
  type: 'forked';
  head: Position;
  id: string;
}

export interface ForkResult_Error {
  type: 'error';
  message: string;
}


/** Result of getting a session */
export type GetResult = GetResult_Ok | GetResult_Error;

export interface GetResult_Ok {
  type: 'ok';
  config: ClaudeCodeConfig;
}

export interface GetResult_Error {
  type: 'error';
  message: string;
}


/** Result of listing sessions */
export type ListResult = ListResult_Ok | ListResult_Error;

export interface ListResult_Ok {
  type: 'ok';
  sessions: ClaudeCodeInfo[];
}

export interface ListResult_Error {
  type: 'error';
  message: string;
}


/** Model selection for Claude Code */
export type Model = "opus" | "sonnet" | "haiku";

/** Pending approval from loopback (simplified for poll response) */
export interface PendingApproval {
  /** When the request was created */
  createdAt: number;
  /** Approval ID (use this with loopback.respond) */
  id: string;
  /** Tool input parameters */
  input: unknown;
  /** Tool requesting approval */
  toolName: string;
  /** Tool use ID from Claude */
  toolUseId: string;
}

/** Result of polling a stream for events */
export type PollResult = PollResult_Ok | PollResult_Error;

export interface PollResult_Ok {
  type: 'ok';
  /** Events since last poll (or from specified offset) */
  events: BufferedEvent[];
  /** True if there are more events available */
  hasMore: boolean;
  /** Pending approvals for this session (if loopback enabled) */
  pendingApprovals: PendingApproval[];
  /** Current read position after this poll */
  readPosition: number;
  /** Current stream status */
  status: StreamStatus;
  /** Total events in buffer */
  totalEvents: number;
}

export interface PollResult_Error {
  type: 'error';
  message: string;
}


/** Status of an active stream */
export type StreamStatus = "running" | "awaiting_permission" | "complete" | "failed";
